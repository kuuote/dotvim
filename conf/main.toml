[[plugins]]
repo = '~/.vim/bundle/gin-preview.vim'
depends = 'gin.vim'
on_cmd = 'GinPreview'
lua_source = '''
local vimx = require('artemis')

vimx.create_autocmd('User', {
  pattern = 'gin-preview:index',
  callback = function()
    local opts = {
      buffer = true,
    }
    vimx.keymap.set('n', '<C-j>', ']czz', opts)
    vimx.keymap.set('n', '<C-k>', '[czz', opts)
    vimx.keymap.set('n', '<C-h>', 'do', opts)
    vimx.keymap.set('n', '<C-l>', 'dp', opts)
    vimx.keymap.set('n', '<Space>s', '<Cmd>update<CR><C-w>k', opts)
  end,
})
'''

[[plugins]]
repo = '~/.vim/bundle/tempcomment.vim'
merged = 1
hook_add = '''
inoremap <expr> <C-c> tempcomment#expr()
'''

[[plugins]]
repo = '$DOTVIM/bundle/vim-operandi'
on_func = ['operandi#open', 'operandi#register']
hook_add = '''
nnoremap <Space><Space> <Cmd>call operandi#open('command')<CR>
'''
hook_source = '''
luafile $DOTVIM/conf/plug/operandi.lua
'''

[[plugins]]
repo = '4513ECHO/denops-gitter.vim'
on_path = 'gitter://'

[[plugins]]
repo = '4513ECHO/vim-vimhelp-hoptag'

[[plugins]]
repo = 'cohama/lexima.vim'
on_event = ['InsertEnter', 'CmdlineEnter']
hook_source = '''
luafile ~/.vim/conf/plug/lexima.lua
call hypermap#map(',s', "lexima#expand('[', 'i')", { 'eval': v:true })
call hypermap#map(',f', "lexima#expand(']', 'i')", { 'eval': v:true })
call hypermap#map(',w', "lexima#expand('{', 'i')", { 'eval': v:true })
call hypermap#map(',r', "lexima#expand('}', 'i')", { 'eval': v:true })
""call hypermap#map(',x', "lexima#expand(\"'\", 'i')", { 'eval': v:true })
""call hypermap#map(',s', "lexima#expand('\"', 'i')", { 'eval': v:true })

" swap () <=> []
call lexima#add_rule({'mode': ':', 'char': '(', 'input_after': ')'})
call lexima#add_rule({'mode': ':', 'char': '(', 'at': '\\\%#'})
call lexima#add_rule({'mode': ':', 'char': ')', 'at': '\%#)', 'leave': 1})
call lexima#add_rule({'mode': ':', 'char': '[', 'input_after': ']'})
call lexima#add_rule({'mode': ':', 'char': '[', 'at': '\\\%#'})
call lexima#add_rule({'mode': ':', 'char': ']', 'at': '\%#]', 'leave': 1})
for s:m in ['i', 'c']
  let s:lm = s:m == 'c' ? ':' : 'i'
  execute printf('%snoremap <expr> ( lexima#expand("[", "%s")', s:m, s:lm)
  execute printf('%snoremap <expr> ) lexima#expand("]", "%s")', s:m, s:lm)
  execute printf('%snoremap <expr> [ lexima#expand("(", "%s")', s:m, s:lm)
  execute printf('%snoremap <expr> ] lexima#expand(")", "%s")', s:m, s:lm)
endfor
'''

[[plugins]]
_sortkey_repo = 'functioncall'
repo = 'machakann/vim-textobj-functioncall'
lazy = 1
hook_add = '''
au ModeChanged *:*[ovV\x16]* ++once ++nested call dein#source('vim-textobj-functioncall')
'''

[[plugins]]
_sortkey_repo = 'functioncall'
repo = 'yuki-yano/vim-textobj-generics'
depends = 'vim-sandwich'
on_source = 'vim-textobj-functioncall'
hook_source = '''
" from readme
let g:sandwich#recipes = get(g:, 'sandwich#recipes', g:sandwich#default_recipes) + [
\ {
\   'buns': ['textobj#generics#input_generics()', '">"'],
\   'expr': 1,
\   'cursor': 'inner_tail',
\   'kind': ['add', 'replace'],
\   'action': ['add'],
\   'input': ['g']
\ },
\ {
\   'external': ['i<', "\<Plug>(textobj-generics-a)"],
\   'noremap': 0,
\   'kind': ['delete', 'replace', 'query'],
\   'input': ['g']
\ },
\ ]
'''

[[plugins]]
repo = 'gw31415/fzyselect.vim'
on_lua = 'fzyselect'
lua_add = '''
if vim.fn.has('nvim') == 1 and vim.g.vim_ui_select == 'fzyselect.vim' then
  vim.ui.select = function(...)
    require('fzyselect').start(...)
  end
end
'''
lua_source = '''
require('vimrc.compat.autocmd').define('FileType', {
  pattern = 'fzyselect',
  callback = function()
    local map = require('vimrc.compat.map').define
    local opts = { buffer = true }
    map('n', 'i', '<Plug>(fzyselect-fzy)', opts)
    map('n', '<CR>', '<Plug>(fzyselect-retu)', opts)
    map('n', '<Esc>', '<Cmd>close<CR>', opts)
  end,
})
'''

[[plugins]]
repo = 'hrsh7th/completion-snippet'

[[plugins]]
repo = 'hrsh7th/vim-searchx'
on_func = 'searchx#start'
hook_add = '''
let g:searchx = {'auto_accept': v:true}
nnoremap s/ <Cmd>call searchx#start({ 'dir': 1 })<CR>
nnoremap s? <Cmd>call searchx#start({ 'dir': 0 })<CR>
'''

[[plugins]]
repo = 'hrsh7th/vim-vsnip'
on_func = 'vsnip#*'
hook_source = '''
let g:vsnip_snippet_dirs = [$HOME .. "/.vim/snippets", dein#get('completion-snippet').path]
if empty(getftype(expand('$DOTVIM/snippets/clean')))
	call system(printf('deno run -A %s %s', expand('$DOTVIM/snippets/convert.ts'), expand('$DOTVIM/snippets')))
	call writefile([], expand('$DOTVIM/snippets/clean'))
endif
'''
lua_source = '''
local booled = require('vimrc.compat.convert').booled
local condmap = require('vimrc.condmap')
local eval = vim.eval or vim.api.nvim_eval
condmap.define {
  lhs = '<CR>',
  cond = booled(function()
    return vim.call('vsnip#jumpable', 1) ~= 0
  end),
  key = 'vsnip',
  priority = condmap.prior.vsnip,
  fn = function()
    return eval([["\<Plug>(vsnip-jump-next)"]])
  end
}
'''

[[plugins]]
repo = 'itchyny/lightline.vim'
depends = 'lightline_skk.vim'
on_event = 'WinNew'
hook_add = '''
set laststatus=1
" やたら遅いし既定値よく見たら1だったのでやめる
" set showtabline=1
'''
lua_source = '''
local vimx = require('artemis')
local let = require('vimrc.util').let

vimx.go.laststatus = 2
vimx.go.showtabline = 2

vimx.g.lightline = {
  active = {
    left = {
      { 'mode', 'paste', 'skk_mode' },
      { 'readonly', 'filename', 'modified', 'test' },
    },
  },
  component_function = {
    git_branch = 'gin#component#branch#ascii',
    git_status = 'gina#component#status#preset',
    skk_mode = 'g:lightline_skk#mode',
  },
  enable = {
    statusline = true,
    tabline = true,
  },
  tabline = {
    left = {
      { 'tabs' },
    },
    right = {
      { 'git_branch', 'git_status' },
    },
  },
}

local special = {
  ['catppuccin-latte'] = 'catppuccin',
  ['catppuccin-mocha'] = 'catppuccin',
  ['catppuccin-frappe'] = 'catppuccin',
  ['catppuccin-macchiato'] = 'catppuccin',
  ['gruvbox-material'] = 'gruvbox_material',
}

local function auto_colorscheme(name)
  local colors = nil
  if special[name] ~= nil then
    colors = special[name]
  elseif vim.fn.globpath(vimx.go.runtimepath, ('autoload/lightline/colorscheme/%s.vim'):format(name)) ~= '' then
    colors = name
  end
  let('g:lightline.colorscheme', colors)
  if colors ~= nil then
    -- edgeのような白黒共用のカラースキームを適用し直す
    local path = vim.fn.globpath(vimx.go.runtimepath, ('autoload/lightline/colorscheme/%s.vim'):format(colors), 1, 1)
    if #path ~= 0 then
      vimx.cmd.source(path[1])
    end
  end
  vim.call('lightline#init')
  vim.call('lightline#colorscheme')
end

auto_colorscheme(vim.g.colors_name)
vimx.create_autocmd('ColorScheme', {
  callback = function()
    auto_colorscheme(vim.fn.expand('<amatch>'))
  end,
})
'''

[[plugins]]
repo = 'junegunn/fzf'
on_func = 'fzf#'

[[plugins]]
repo = 'kana/vim-operator-user'

[[plugins]]
repo = 'kana/vim-textobj-entire'

hook_add = '''
onoremap ae <Plug>(textobj-entire-a)
onoremap ie <Plug>(textobj-entire-i)
xnoremap ae <Plug>(textobj-entire-a)
xnoremap ie <Plug>(textobj-entire-i)
'''

[plugins.on_map]
o = '<Plug>(textobj-entire-'
x = '<Plug>(textobj-entire-'

[[plugins]]
repo = 'kana/vim-textobj-line'
hook_add = '''
onoremap al <Plug>(textobj-line-a)
onoremap il <Plug>(textobj-line-i)
xnoremap al <Plug>(textobj-line-a)
xnoremap il <Plug>(textobj-line-i)
'''

[plugins.on_map]
o = '<Plug>(textobj-line-'
x = '<Plug>(textobj-line-'

[[plugins]]
repo = 'kana/vim-textobj-user'

[[plugins]]
repo = 'kuuote/jsonyaml.vim'

[[plugins]]
repo = 'kuuote/mydicts'

[[plugins]]
repo = 'lambdalisue/fern.vim'
on_cmd = 'Fern'
hook_add = '''
nnoremap <Space>F <Cmd>Fern . -reveal=%:p<CR>
'''

[[plugins]]
repo = 'lambdalisue/gin.vim'
on_func = 'gin#component*'
on_cmd = ['Gin', 'Gin*']
denops_wait = false
hook_source = '''
autocmd FileType gin-status nnoremap <buffer> c <Cmd>Gin commit<CR>
autocmd User GinComponentPost redrawtabline
" 遅延してるとDenopsPluginPostにフックが生えないので生やす"
call gin#component#branch#ascii()
'''

[[plugins]]
repo = 'lambdalisue/gina.vim'
on_cmd = 'Gina'
lua_source = '''
local call = require('vimrc.compat.convert').call
call('gina#custom#mapping#nmap', 'status', ',c', '<Cmd>Gina commit -v --opener=tabedit<CR>', {
  noremap = true,
  nowait = true,
  silent = true,
})
if call('dein#tap', 'ddc.vim') == 1 then
  call('ddc#custom#patch_filetype', 'gina-commit', 'specialBufferCompletion', true)
end
'''

[[plugins]]
repo = 'lambdalisue/guise.vim'
lua_add = '''
vim.g.guise_edit_opener = 'call g:GuiseCloser() | edit'
vim.g.GuiseCloser = function()
  local b = vim.fn.bufnr()
  vim.fn.timer_start(0, function()
    local cmd = vim.command or vim.cmd
    cmd(b .. 'bdelete!')
  end)
end
'''

[[plugins]]
repo = 'lambdalisue/kensaku.vim'
hook_add = '''
let g:kensaku_dictionary_cache = '/data/vim/cache/kensaku_dict'
'''

[[plugins]]
repo = 'lambdalisue/mr.vim'
on_event = 'BufNewFile,BufReadPre,BufWritePre' # 事前に読むためPreに引っ掛ける必要がある
hook_source = '''
let g:mr#mru#filename = '/data/mr/mru'
let g:mr#mrw#filename = '/data/mr/mrw'
let g:mr#mrr#filename = '/data/mr/mrr'
'''

[[plugins]]
repo = 'lambdalisue/suda.vim'
on_cmd = ['SudaRead', 'SudaWrite']

[[plugins]]
repo = 'machakann/vim-sandwich'
on_map = '<Plug>(sandwich-'
hook_add = '''
au ModeChanged *:*[ovV\x16]* ++once ++nested call dein#source('vim-sandwich')
nnoremap sa  <Plug>(sandwich-add)
nnoremap sd  <Plug>(sandwich-delete)
nnoremap sdb <Plug>(sandwich-delete-auto)
nnoremap sr  <Plug>(sandwich-replace)
nnoremap srb <Plug>(sandwich-replace-auto)
'''
lua_post_source = '''
local vimx = require('artemis')
-- https://github.com/yuki-yano/dotfiles/blob/f1b6ac0c2a178177cc546bab19a175a498192e1e/.vim/lua/plugins/coding.lua#L451-L458
-- console.log() などをまとめて指定できるやつ
vim.g['sandwich#magicchar#f#patterns'] = {
  {
    header = [[\<\%(\h\k*\.\)*\h\k*]],
    bra = '(',
    ket = ')',
    footer = '',
  },
}
-- https://github.com/yuki-yano/dotfiles/blob/f1b6ac0c2a178177cc546bab19a175a498192e1e/.vim/lua/plugins/coding.lua#L485-L487
-- saa( などで空白を含めないようにするやつ
vimx.fn.operator.sandwich.set('add', 'char', 'skip_space', 1)
vim.cmd([[autocmd ModeChanged [vV\x16]*:* call operator#sandwich#set('add', 'char', 'skip_space', 1)]])
vim.cmd([[autocmd ModeChanged *:[vV\x16]* call operator#sandwich#set('add', 'char', 'skip_space', 0)]])
'''

[[plugins]]
repo = 'matsui54/denops-popup-preview.vim'
hook_add = '''
" plugin無いしこの遅延方法でよさそう
" on_eventでhookかけるとVimで入力文字を吸うのでこれでいい
autocmd TextChangedI * ++once ++nested call popup_preview#enable()
'''

[[plugins]]
repo = 'mattn/vim-sonictemplate'
on_cmd = 'Template'
on_func = 'sonictemplate#postfix'
hook_add = '''
let g:sonictemplate_vim_template_dir = $HOME .. '/.vim/template'
call hypermap#map(';b',"\<C-r>=sonictemplate#postfix()\<CR>")
'''

[[plugins]]
repo = 'rbtnn/vim-layout'
on_cmd = ['LayoutLoad', 'LayoutSave']
on_func = 'layout#*'

[[plugins]]
repo = 'rbtnn/vim-textobj-string'

lua_add = '''
vim.g.vim_textobj_string_mapping = 'c' -- colon
'''

[plugins.on_map]
o = '<Plug>(textobj-string-'
x = '<Plug>(textobj-string-'

[[plugins]]
repo = 'Shougo/dein.vim'
merged = 0
lua_add = '''
require('vimrc.command').define('DduDein', function()
  require('ddu').start {
    {
      name = 'dein',
      options = {
        sorters = { 'sorter_alpha', 'sorter_distance' },
      },
    },
  }
end)
'''

[[plugins]]
repo = 'Shougo/junkfile.vim'
on_cmd = 'JunkfileOpen'
on_func = 'ddu#start'
hook_source = '''
let g:junkfile#directory = '/data/junkfile'
'''

[[plugins]]
repo = 'skanehira/denops-gh.vim'
on_if = 'bufname() =~# "^gh://"'

[[plugins]]
repo = 'skk-dev/dict'
if = 0

[[plugins]]
repo = 'skk-dev/skktools'

[[plugins]]
repo = 'tani/vim-artemis'
if = 0 # dein.vim読み込み前に自前で読んでるので無効化しておく

[[plugins]]
repo = 'thinca/vim-localrc'
# on_event = ['BufNewFile', 'BufReadPost']

[[plugins]]
repo = 'thinca/vim-partedit'
on_cmd = 'Partedit'

[[plugins]]
repo = 'thinca/vim-prettyprint'
on_cmd = 'PrettyPrint'

[[plugins]]
repo = 'thinca/vim-qfreplace'
on_cmd = 'Qfreplace'

[[plugins]]
repo = 'thinca/vim-quickrun'
on_cmd = 'QuickRun'
lua_source = '''
vim.g.quickrun_config = {
  lua = {
    command = 'nvim',
    tempfile = '%{tempname()}.lua',
    exec = [[%c --clean --headless -c 'source %s' -c 'cquit 0']],
  },
  ['typescript/deno/test'] = {
    command = 'deno',
    cmdopt = '--no-check --allow-all --unstable',
    tempfile = '%{tempname()}.ts',
    exec = { '%c test %o %s' },
  },
  -- from @ycino
  yq = {
    exec = 'cat %s | yq eval --output-format=json'
  },
}
'''

[[plugins]]
repo = 'thinca/vim-ref'
on_cmd = 'Ref'

[[plugins]]
repo = 'thinca/vim-themis'

[[plugins]]
repo = 'tweekmonster/helpful.vim'
if = 0

[[plugins]]
repo = 'tyru/capture.vim'
on_cmd = 'Capture'
hook_add = '''
cnoremap <C-c> <Home>Capture <CR>
'''

[[plugins]]
repo = 'uga-rosa/linkformat.vim'
on_cmd = 'LinkFormatPaste'
hook_source = '''
luafile ~/.vim/conf/plug/linkformat.lua
'''

[[plugins]]
repo = 'uga-rosa/scorpeon.vim'
on_cmd = 'ScorpeonHighlightEnable'
lua_source = '''
vim.g.scorpeon_extensions_path = require('vimrc.compat.convert').convert {
  '/usr/lib/code/extensions',
}
'''

[[plugins]]
repo = 'vim-denops/denops.vim'
hook_add = '''
" let g:denops_server_addr = '127.0.0.1:32123'
let g:denops#server#deno_args = ['-q', '--no-check', '--unstable', '-A', '--no-lock']
'''

[[plugins]]
repo = 'vim-jp/vimdoc-ja'
hook_add = '''
set helplang=ja
'''

[[plugins]]
repo = 'vim-skk/skkeleton'
hook_add = '''
autocmd User skkeleton-initialize-pre ++once ++nested luafile ~/.vim/conf/plug/skkeleton.lua
autocmd SourcePost *vimrc/sticky.vim call vimrc#sticky#register("\<Space>", "\<Plug>(skkeleton-enable)")

tnoremap <C-z> <Plug>(skkeleton-enable)

autocmd User DenopsPluginPost:skkeleton call skkeleton#initialize()
autocmd User skkeleton-enable-pre call s:skkeleton_pre()
function! s:skkeleton_pre() abort
  if dein#is_sourced('ddc.vim')
    let b:skkeleton_ddc_backup = ddc#custom#get_buffer()
    let sources = get(b:, 'skkeleton_ddc_sources', ['skkeleton'])
    call ddc#custom#patch_buffer('sources', sources)
    call ddc#custom#patch_buffer('specialBufferCompletion', v:true)
  endif
  if dein#is_sourced('nvim-cmp')
    lua require('vimrc.plug.cmp').change_sources('skkeleton')
  endif
endfunction
autocmd User skkeleton-disable-pre call s:skkeleton_post()
function! s:skkeleton_post() abort
  " Restore current sources
  if exists('b:skkeleton_ddc_backup')
    call ddc#custom#set_buffer(b:skkeleton_ddc_backup)
  endif
  if dein#is_sourced('nvim-cmp')
    lua require('vimrc.plug.cmp').change_sources('default')
  endif
endfunction
'''

[[plugins]]
repo = 'yasunori-kirin0418/lightline_skk.vim'
lazy = 1

[[plugins]]
repo = 'yuki-yano/fern-preview.vim'
on_source = 'fern.vim'
hook_add = '''
function! s:fern_preview_map() abort
  nmap <silent> <buffer> p     <Plug>(fern-action-preview:toggle)
  nmap <silent> <buffer> P     <Plug>(fern-action-preview:auto:toggle)
  nmap <silent> <buffer> <C-d> <Plug>(fern-action-preview:scroll:down:half)
  nmap <silent> <buffer> <C-u> <Plug>(fern-action-preview:scroll:up:half)
endfunction

augroup vimrc
  autocmd FileType fern call s:fern_preview_map()
augroup END
'''

[[plugins]]
repo = 'yuki-yano/fuzzy-motion.vim'
on_cmd = 'FuzzyMotion'
hook_add = '''
nnoremap <Tab> <Cmd>FuzzyMotion<CR>
'''
hook_source = '''
" from https://github.com/yuki-yano/dotfiles/blob/7f10462d12228f57ea3cf86d61f3b22d4728b6f1/.vimrc#L3030
" 2個目の条件(foo.bar.bazみたいなのにマッチさせる設定)にスペースを増やした(コマンドにもヒットさせたかった)
" 最後に行全体にマッチさせる設定を入れた(若干pounceっぽく使える気がする)
let g:fuzzy_motion_word_regexp_list = ['[0-9a-zA-Z_-]+',  '([0-9a-zA-Z_-]|[. ])+', '([0-9a-zA-Z]|[()<>.-_#''"]|(\s=+\s)|(,\s)|(:\s)|(\s=>\s))+', '.+']

let g:fuzzy_motion_matchers = ['fzf', 'kensaku']
'''

[[plugins]]
repo = 'yuki-yano/fzf-preview.vim'
on_cmd = 'FzfPreview*'
hook_add = '''
let g:fzf_preview_grep_cmd = 'rg --line-number --no-heading --color=never --sort=path --with-filename'

nnoremap <silent> gs <Cmd>FzfPreviewGitStatusRpc<CR>
nnoremap <fzf-p> <Nop>
nmap <Space>z <fzf-p>
" nnoremap <silent> <C-p> <Cmd>FzfPreviewDirectoryFilesRpc<CR>
nnoremap <silent> <fzf-p>L :<C-u>FzfPreviewProjectGrepRpc --experimental-fast -add-fzf-arg=--exact --add-fzf-arg=--no-sort . <C-r>=expand('%:p')<CR><CR>
nnoremap <silent> <fzf-p>f <Cmd>FzfPreviewCommandPaletteRpc<CR>
nnoremap <silent> <fzf-p>l <Cmd>FzfPreviewLinesRpc<CR>
nnoremap <silent> <fzf-p>p :<C-u>FzfPreviewProjectGrep --experimental-fast<Space>
nnoremap <silent> <fzf-p>s <Cmd>FzfPreviewGitStatusRpc<CR>
nnoremap <silent> <fzf-p>w <Cmd>FzfPreviewProjectMrwFilesRpc --add-fzf-arg=--no-sort<CR>
'''

[[plugins]]
repo = 'yuki-yano/vim-operator-replace'
hook_add = '''
nnoremap R <Plug>(operator-replace)
xnoremap R <Plug>(operator-replace)
nnoremap <Space>r R
'''

[plugins.on_map]
o = '<Plug>(operator-replace)'
x = '<Plug>(operator-replace)'

