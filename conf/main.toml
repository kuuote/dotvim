[[plugins]]
repo = '4513ECHO/vim-readme-viewer'

[[plugins]]
repo = 'c000/rapidfire.vim'
hook_add = '''
function! s:rapidfire_search_config() abort
  let file = findfile('.rapidfire', '.;')
  if empty(file)
    let g:rapidfire#persistent_filename = '~/.vim/.rapidfire'
  else
    let g:rapidfire#persistent_filename = readfile(file)[0]
  endif
endfunction
call s:rapidfire_search_config()
'''

[[plugins]]
repo = 'cohama/lexima.vim'
hook_source = '''
luafile ~/.vim/conf/plug/lexima.lua
call hypermap#map(';s', "lexima#expand('(', 'i')", { 'eval': v:true })
call hypermap#map(';f', "lexima#expand(')', 'i')", { 'eval': v:true })
call hypermap#map(';w', "lexima#expand('{', 'i')", { 'eval': v:true })
call hypermap#map(';r', "lexima#expand('}', 'i')", { 'eval': v:true })
'''

[[plugins]]
repo = 'gw31415/fzyselect.vim'
lua_source = '''
if vim.fn.has('nvim') == 1 and vim.g.vim_ui_select == 'fzyselect.vim' then
  vim.ui.select = require('fzyselect').start
end
require('vimrc.autocmd').define('FileType', {
  pattern = 'fzyselect',
  callback = function()
    local map = require('vimrc.map').define
    local opts = {buffer = true}
    map('n', 'i', '<Plug>(fzyselect-fzy)', opts)
    map('n', '<CR>', '<Plug>(fzyselect-retu)', opts)
    map('n', '<Esc>', '<Cmd>close<CR>', opts)
  end
})
'''

[[plugins]]
repo = 'hrsh7th/vim-vsnip'
hook_add = '''
imap <C-b> <Plug>(vsnip-expand-or-jump)
let g:vsnip_snippet_dir = $HOME .. "/.vim/snippets"
'''

[[plugins]]
repo = 'itchyny/lightline.vim'
lua_add = '''
local convert = require('vimrc.convert').convert

vim.g.lightline = convert {
  active = {
    left = {
      { 'mode', 'paste', 'skk_mode' },
      { 'readonly', 'filename', 'modified', 'test' },
    },
  },
  component_function = {
    git_branch = 'gitbranch#name',
    git_status = 'gina#component#status#preset',
    skk_mode = 'g:lightline_skk#mode',
  },
  enable = {
    statusline = true,
    tabline = true,
  },
  tabline = {
    left = {
      { 'tabs' },
    },
    right = {
      {'git_branch', 'git_status'},
    },
  },
}
'''
hook_add = '''
let s:special = {
\   'catppuccin-latte': { -> 'catppuccin' },
\   'catppuccin-mocha': { -> 'catppuccin' },
\   'catppuccin-frappe': { -> 'catppuccin' },
\   'catppuccin-macchiato': { -> 'catppuccin' },
\   'gruvbox-material': { -> 'gruvbox_material' },
\ }

" lightlineのカラースキームを自動で適用するやつ
function! s:lightline_colorscheme(name) abort
  if has_key(s:special, a:name)
    let g:lightline.colorscheme = s:special[a:name]()
  elseif globpath(&runtimepath, printf('autoload/lightline/colorscheme/%s.vim', a:name)) ==# ''
    unlet g:lightline.colorscheme
  else
    let g:lightline.colorscheme = a:name
  endif
  if has_key(g:lightline, 'colorscheme')
    " edgeのような白黒共用のカラースキームを適用し直す
    let path = globpath(&runtimepath, printf('autoload/lightline/colorscheme/%s.vim', g:lightline.colorscheme), v:true, v:true)
    if !empty(path)
      execute 'source' path[0]
    endif
  endif
  call lightline#init()
  call lightline#colorscheme()
endfunction

autocmd ColorScheme * call s:lightline_colorscheme(expand('<amatch>'))
'''

[[plugins]]
repo = 'itchyny/vim-gitbranch'

[[plugins]]
repo = 'junegunn/fzf'

[[plugins]]
repo = 'kana/vim-textobj-entire'

hook_add = '''
onoremap ae <Plug>(textobj-entire-a)
onoremap ie <Plug>(textobj-entire-i)
xnoremap ae <Plug>(textobj-entire-a)
xnoremap ie <Plug>(textobj-entire-i)
'''

[plugins.on_map]
o = '<Plug>(textobj-entire-'
x = '<Plug>(textobj-entire-'

[[plugins]]
repo = 'kana/vim-textobj-line'
hook_add = '''
onoremap al <Plug>(textobj-line-a)
onoremap il <Plug>(textobj-line-i)
xnoremap al <Plug>(textobj-line-a)
xnoremap il <Plug>(textobj-line-i)
'''

[plugins.on_map]
o = '<Plug>(textobj-line-'
x = '<Plug>(textobj-line-'

[[plugins]]
repo = 'kana/vim-textobj-user'

[[plugins]]
repo = 'kuuote/vim-fuzzyhistory'
hook_add = '''
nmap <C-f> <Plug>(fuzzy-history)
'''

[[plugins]]
repo = 'lambdalisue/fern.vim'
hook_add = '''
nnoremap <Space>f <Cmd>Fern . -reveal=%:p<CR>
'''

[[plugins]]
repo = 'lambdalisue/gin.vim'
hook_add = '''
autocmd FileType gin-status nnoremap <buffer> ,c <Cmd>Gin commit<CR>
autocmd User GinComponentPost redrawtabline
'''

[[plugins]]
repo = 'lambdalisue/gina.vim'
on_cmd = 'Gina'
lua_source = '''
local vimeval = require('vimrc.convert').call
vimeval('gina#custom#mapping#nmap', 'status', ',c', '<Cmd>Gina commit -v --opener=tabedit<CR>', {
  noremap = true,
  nowait = true,
  silent = true,
})
if vimeval('dein#tap', 'ddc.vim') == 1 then
  vimeval('ddc#custom#patch_filetype', 'gina-commit', 'specialBufferCompletion', true)
end
'''

[[plugins]]
repo = 'lambdalisue/guise.vim'

[[plugins]]
repo = 'lambdalisue/mr.vim'

[[plugins]]
repo = 'lambdalisue/suda.vim'
on_cmd = ['SudaRead', 'SudaWrite']

[[plugins]]
repo = 'machakann/vim-sandwich'
hook_source = '''
" from https://scrapbox.io/vim-jp/sandwich,_textobj%E3%81%A7Generics%E3%82%92%E6%89%B1%E3%81%86
let g:sandwich#recipes = g:sandwich#default_recipes + [
\ {
\   'buns': ['InputGenerics()', '">"'],
\   'expr': 1,
\   'cursor': 'inner_tail',
\   'kind': ['add', 'replace'],
\   'action': ['add'],
\   'input': ['g']
\ },
\ {
\   'external': ['i<', "\<Plug>(textobj-functioncall-generics-a)"],
\   'noremap': 0,
\   'kind': ['delete', 'replace', 'query'],
\   'input': ['g']
\ },
\ ]

function! InputGenerics() abort
  let genericsname = input('Generics Name: ', '')
  if genericsname ==# ''
    throw 'OperatorSandwichCancel'
  endif
  return genericsname . '<'
endfunction
'''

[[plugins]]
repo = 'machakann/vim-textobj-functioncall'
hook_add = '''
" from https://scrapbox.io/vim-jp/sandwich,_textobj%E3%81%A7Generics%E3%82%92%E6%89%B1%E3%81%86
let g:textobj_functioncall_no_default_key_mappings = 1
omap <silent> if <Plug>(textobj-functioncall-innerparen-i)
xmap <silent> if <Plug>(textobj-functioncall-innerparen-i)
omap <silent> af <Plug>(textobj-functioncall-i)
xmap <silent> af <Plug>(textobj-functioncall-i)

let g:textobj_functioncall_generics_patterns = [
\ {
\   'header' : '\<\%(\h\k*\.\)*\h\k*',
\   'bra'    : '<',
\   'ket'    : '>',
\   'footer' : '',
\ },
\ ]

onoremap <silent> <Plug>(textobj-functioncall-generics-i) :<C-u>call textobj#functioncall#ip('o', g:textobj_functioncall_generics_patterns)<CR>
xnoremap <silent> <Plug>(textobj-functioncall-generics-i) :<C-u>call textobj#functioncall#ip('x', g:textobj_functioncall_generics_patterns)<CR>
onoremap <silent> <Plug>(textobj-functioncall-generics-a) :<C-u>call textobj#functioncall#i('o', g:textobj_functioncall_generics_patterns)<CR>
xnoremap <silent> <Plug>(textobj-functioncall-generics-a) :<C-u>call textobj#functioncall#i('x', g:textobj_functioncall_generics_patterns)<CR>

omap <silent> ig <Plug>(textobj-functioncall-generics-i)
xmap <silent> ig <Plug>(textobj-functioncall-generics-i)
omap <silent> ag <Plug>(textobj-functioncall-generics-a)
xmap <silent> ag <Plug>(textobj-functioncall-generics-a)
'''

[[plugins]]
repo = 'matsui54/denops-popup-preview.vim'
hook_source = '''
call popup_preview#enable()
'''

[[plugins]]
repo = 'mattn/vim-sonictemplate'
hook_add = '''
let g:sonictemplate_vim_template_dir = $HOME .. '/.vim/template'
call hypermap#map(';b',"\<C-r>=sonictemplate#postfix()\<CR>")
'''

[[plugins]]
repo = 'monaqa/dps-dial.vim'
hook_add = '''
nmap  <C-a>  <Plug>(dps-dial-increment)
nmap  <C-x>  <Plug>(dps-dial-decrement)
xmap  <C-a>  <Plug>(dps-dial-increment)
xmap  <C-x>  <Plug>(dps-dial-decrement)
xmap g<C-a> g<Plug>(dps-dial-increment)
xmap g<C-x> g<Plug>(dps-dial-decrement)
'''

[[plugins]]
repo = 'rbtnn/vim-textobj-string'
lua_add = '''
vim.g.vim_textobj_string_mapping = 'c' -- colon
'''

[[plugins]]
repo = 'Shougo/dein.vim'
merged = 0

[[plugins]]
repo = 'Shougo/junkfile.vim'
hook_add = '''
let g:junkfile#directory = '/data/junkfile'
'''

[[plugins]]
repo = 'skanehira/denops-gh.vim'

[[plugins]]
repo = 'skk-dev/dict'

[[plugins]]
repo = 'skk-dev/skktools'

[[plugins]]
repo = 'thinca/vim-localrc'

[[plugins]]
repo = 'thinca/vim-partedit'

[[plugins]]
repo = 'thinca/vim-qfreplace'

[[plugins]]
repo = 'thinca/vim-quickrun'

[[plugins]]
repo = 'thinca/vim-ref'

[[plugins]]
repo = 'thinca/vim-themis'

[[plugins]]
repo = 'tweekmonster/helpful.vim'

[[plugins]]
repo = 'tyru/capture.vim'

[[plugins]]
repo = 'uga-rosa/linkformat.vim'
on_cmd = 'LinkFormatPaste'
hook_source = '''
luafile ~/.vim/conf/plug/linkformat.lua
'''

[[plugins]]
repo = 'vim-denops/denops.vim'

[[plugins]]
repo = 'vim-jp/vimdoc-ja'
hook_add = '''
set helplang=ja
'''

[[plugins]]
repo = 'vim-skk/skkeleton'
lua_add = '''
local au = require('vimrc.autocmd').define
local vimeval = require('vimrc.convert').call

local dictPath = vimeval('dein#get', 'dict').path

vim.g['skkeleton#debug'] = false

au('User', {
  pattern = 'skkeleton-initialize-pre',
  callback = function()
    vimeval('skkeleton#config', {
      eggLikeNewline = true,
      globalDictionaries = {
        dictPath .. '/SKK-JISYO.edict2',
        dictPath .. '/SKK-JISYO.L',
      },
      registerConvertResult = true,
      showCandidatesCount = 1,
      -- from shougo-s-github
      markerHenkan = '<>',
      markerHenkanSelect = '>>',
    })
    -- USキーボードの n' で「ん」を打てるやつをJISキーボードでもやる
    vimeval('skkeleton#register_kanatable', 'rom', {
      ['n:'] = { 'ん', '' },
    })
  end,
})
'''
hook_add = '''

call hypermap#map(';j', 'eval(maparg("<Plug>(skkeleton-enable)", mode()))', {'eval': v:true})
" call hypermap#map('jj', 'eval(maparg("<Plug>(skkeleton-toggle)", mode()))', {'eval': v:true})


autocmd User skkeleton-enable-pre call s:skkeleton_pre()
function! s:skkeleton_pre() abort
  " Save current sources
  let b:skkeleton_ddc_sources_backup = get(ddc#custom#get_current(), 'sources', [])
  let sources = get(b:, 'skkeleton_ddc_sources', ['skkeleton'])
  call ddc#custom#patch_buffer('sources', sources)
  call ddc#custom#patch_buffer('specialBufferCompletion', v:true)
  " call pum#set_option('setline_insert', v:true)
endfunction
autocmd User skkeleton-disable-pre call s:skkeleton_post()
function! s:skkeleton_post() abort
  " Restore current sources
  call ddc#custom#patch_buffer('sources', b:skkeleton_ddc_sources_backup)
  call pum#set_option('setline_insert', v:false)
endfunction
'''

[[plugins]]
repo = 'yasunori-kirin0418/lightline_skk.vim'

[[plugins]]
repo = 'yuki-yano/fern-preview.vim'
hook_add = '''
function! s:fern_preview_map() abort
  nmap <silent> <buffer> p     <Plug>(fern-action-preview:toggle)
  nmap <silent> <buffer> P     <Plug>(fern-action-preview:auto:toggle)
  nmap <silent> <buffer> <C-d> <Plug>(fern-action-preview:scroll:down:half)
  nmap <silent> <buffer> <C-u> <Plug>(fern-action-preview:scroll:up:half)
endfunction

augroup vimrc
  autocmd FileType fern call s:fern_preview_map()
augroup END
'''

[[plugins]]
repo = 'yuki-yano/fuzzy-motion.vim'
hook_add = '''
" from https://github.com/yuki-yano/dotfiles/blob/7f10462d12228f57ea3cf86d61f3b22d4728b6f1/.vimrc#L3030
" 2個目の条件(foo.bar.bazみたいなのにマッチさせる設定)にスペースを増やした(コマンドにもヒットさせたかった)
" 最後に行全体にマッチさせる設定を入れた(若干pounceっぽく使える気がする)
let g:fuzzy_motion_word_regexp_list = ['[0-9a-zA-Z_-]+',  '([0-9a-zA-Z_-]|[. ])+', '([0-9a-zA-Z]|[()<>.-_#''"]|(\s=+\s)|(,\s)|(:\s)|(\s=>\s))+', '.+']

nnoremap <Tab> <Cmd>FuzzyMotion<CR>
'''

[[plugins]]
repo = 'yuki-yano/fzf-preview.vim'
hook_add = '''
let g:fzf_preview_grep_cmd = 'rg --line-number --no-heading --color=never --sort=path --with-filename'

nnoremap <fzf-p> <Nop>
nmap 'z <fzf-p>
" nnoremap <silent> <C-p> <Cmd>FzfPreviewDirectoryFilesRpc<CR>
nnoremap <silent> <fzf-p>L :<C-u>FzfPreviewProjectGrepRpc --experimental-fast -add-fzf-arg=--exact --add-fzf-arg=--no-sort . <C-r>=expand('%:p')<CR><CR>
nnoremap <silent> <fzf-p>f <Cmd>FzfPreviewCommandPaletteRpc<CR>
nnoremap <silent> <fzf-p>l <Cmd>FzfPreviewLinesRpc<CR>
nnoremap <silent> <fzf-p>p :<C-u>FzfPreviewProjectGrep --experimental-fast<Space>
nnoremap <silent> <fzf-p>s <Cmd>FzfPreviewGitStatusRpc<CR>
nnoremap <silent> <fzf-p>w <Cmd>FzfPreviewProjectMrwFilesRpc --add-fzf-arg=--no-sort<CR>

" non prefix shortcut
nnoremap gs :FzfPreviewGitStatusRpc<CR>
'''

[[plugins]]
repo = 'yuki-yano/vim-operator-replace'
hook_add = '''
nnoremap R <Plug>(operator-replace)
xnoremap R <Plug>(operator-replace)
nnoremap <Space>r R
'''

[plugins.on_map]
o = '<Plug>(operator-replace)'
x = '<Plug>(operator-replace)'

