[[plugins]]
repo = 'kuuote/ddc-source-suconv'

[[plugins]]
repo = 'LumaKernel/ddc-source-file'

[[plugins]]
repo = 'matsui54/ddc-buffer'

[[plugins]]
repo = 'Shougo/ddc-matcher_head'

[[plugins]]
repo = 'Shougo/ddc-sorter_rank'

[[plugins]]
repo = 'Shougo/ddc-source-around'

[[plugins]]
repo = 'Shougo/ddc-source-cmdline'

[[plugins]]
repo = 'Shougo/ddc-source-line'

[[plugins]]
repo = 'Shougo/ddc-source-zsh'

[[plugins]]
repo = 'Shougo/ddc-ui-native'

[[plugins]]
repo = 'Shougo/ddc-ui-none'

[[plugins]]
repo = 'Shougo/ddc-ui-pum'

[[plugins]]
repo = 'Shougo/ddc.vim'
on_event = ['CmdlineEnter', 'InsertEnter']
hook_source = '''
" frontは出現したら何よりも先に選びたいやつ
" 次にバッファ固有の物、その後に通常という戦略で行く
let g:vimrc#ddc_sources = ['around', 'buffer']
if has('nvim')
  let g:vimrc#ddc_sources_front = ['tsnip', 'vsnip', 'file']
else
  let g:vimrc#ddc_sources_front = ['vsnip', 'file']
endif
" insert space for paragraph selector
" vip => :!jq -S .
let s:config_json =<< UNKO

{
  "autoCompleteEvents": [
    "InsertEnter",
    "TextChangedI",
    "TextChangedP",
    "TextChangedT",
    "CmdlineEnter",
    "CmdlineChanged"
  ],
  "backspaceCompletion": true,
  "cmdlineSources": [
    "cmdline"
  ],
  "filterParams": {
    "matcher_substring": {
      "highlightMatched": "FuzzyAccent"
    }
  },
  "sourceOptions": {
    "_": {
      "converters": [
        "converter_fuzzy"
      ],
      "ignoreCase": true,
      "matchers": [
        "matcher_fuzzy"
      ],
      "sorters": [
        "sorter_fuzzy"
      ]
    },
    "around": {
      "mark": "A"
    },
    "buffer": {
      "mark": "B"
    },
    "cmdline": {
      "minAutoCompleteLength": 0
    },
    "cmdline_help": {
      "maxItems": 20
    },
    "file": {
      "forceCompletionPattern": "\\S/\\S*",
      "isVolatile": true,
      "mark": "F",
      "minAutoCompleteLength": 1000,
      "sorters": [
        "sorter_file",
        "sorter_fuzzy"
      ]
    },
    "necovim": {
      "mark": "V"
    },
    "nvim-lsp": {
      "forceCompletionPattern": "\\.\\w*|:\\w*|->\\w*",
      "mark": "lsp",
      "minAutoCompleteLength": 1
    },
    "skkeleton": {
      "converters": [],
      "isVolatile": true,
      "mark": "skk",
      "matchers": [
        "skkeleton"
      ],
      "maxCandidates": 50,
      "minAutoCompleteLength": 2,
      "sorters": []
    }
  },
  "sourceParams": {
    "file": {
      "filenameChars": "[:keyword:].",
      "projFromCwdMaxItems": [
        0
      ]
    }
  },
  "ui": "pum"
}

UNKO
let g:vimrc#ddc_config = s:config_json->join('')->json_decode()
unlet s:config_json
let g:vimrc#ddc_config['sources'] = g:vimrc#ddc_sources_front + g:vimrc#ddc_sources
call ddc#custom#patch_global(g:vimrc#ddc_config)
doautocmd <nomodeline> User vimrc-ddc
call ddc#enable()

autocmd CmdlineEnter : call ddc#enable_cmdline_completion()

" acwriteセットされてるファイルで補完効かなくて困ることは無いと思う
autocmd OptionSet buftype if &buftype ==# 'acwrite' | call ddc#custom#patch_buffer('specialBufferCompletion', v:true) | endif

luafile ~/.vim/conf/plug/ddc.lua
'''

[[plugins]]
repo = 'Shougo/neco-vim'
on_ft = ['vim']
hook_source = '''
function! s:setup_necovim() abort
  call ddc#custom#patch_filetype(['vim'], 'sources', g:vimrc#ddc_sources_front + ['necovim'] + g:vimrc#ddc_sources)
endfunction
autocmd User vimrc-ddc call s:setup_necovim()
'''

[[plugins]]
repo = 'Shougo/pum.vim'
on_source = 'ddc.vim'
hook_source = '''
" inoremap <C-n>   <Cmd>call pum#map#select_relative(+1)<CR>
" inoremap <C-p>   <Cmd>call pum#map#select_relative(-1)<CR>
inoremap <C-y>   <Cmd>call pum#map#confirm()<CR>
inoremap <C-q>   <Cmd>call pum#map#cancel()<CR>

cnoremap <Tab>   <Cmd>call pum#map#insert_relative(+1)<CR>
cnoremap <S-Tab> <Cmd>call pum#map#insert_relative(-1)<CR>

" tnoremap <Tab>   <Cmd>call pum#map#insert_relative(+1)<CR>
" tnoremap <S-Tab> <Cmd>call pum#map#insert_relative(-1)<CR>

call pum#set_option('use_complete', v:true)
set shortmess+=c " suppress 'The only match'
'''
lua_source = '''
local booled = require('vimrc.compat.convert').booled
local condmap = require('vimrc.condmap')
local copy = require('kutil.function').copy
local eval = vim.eval or vim.api.nvim_eval

local function cm(opts)
  opts = copy(opts)
  opts.mode = 'i'
  opts.key = 'pum.vim'
  condmap.define(opts)
end

cm {
  lhs = '<Tab>',
  cond = booled(vim.fn['pum#visible']),
  fn = function()
    return eval([["\<Cmd>call pum#map#insert_relative(1)\<CR>"]])
  end,
}

cm {
  lhs = '<S-Tab>',
  cond = booled(vim.fn['pum#visible']),
  fn = function()
    return eval([["\<Cmd>call pum#map#insert_relative(-1)\<CR>"]])
  end,
}

cm {
  lhs = '<CR>',
  cond = booled(vim.fn['pum#entered']),
  fn = function()
    return eval([["\<Cmd>call pum#map#confirm()\<CR>"]])
  end,
}
'''

[[plugins]]
repo = 'takker99/ddc-bitap'

[[plugins]]
repo = 'tani/ddc-fuzzy'

